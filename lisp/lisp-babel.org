#+TITLE: lisp-babel
#+DATE: <2013-08-31 Sat>
#+AUTHOR: Derek Feichtinger
#+EMAIL: derek.feichtinger@psi.ch
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not LOGBOOK) date:t e:t
#+OPTIONS: email:nil f:t inline:t num:t p:nil pri:nil stat:t tags:t
#+OPTIONS: tasks:t tex:t timestamp:t toc:t todo:t |:t
#+CREATOR: Emacs 24.3.1 (Org mode 8.0.7)
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en
#+SELECT_TAGS: export

* Version information
  #+BEGIN_SRC emacs-lisp :results output
    (princ (concat (format "Emacs version: %s\n" (emacs-version))
                   (format "org version: %s\n" (org-version))))
    
  #+END_SRC

  #+RESULTS:
  : Emacs version: GNU Emacs 24.3.1 (i686-pc-linux-gnu, GTK+ Version 3.4.2)
  :  of 2014-02-22 on chindi10, modified by Debian
  : org version: 8.2.5h

* using a table as input

  We first create a table from a lisp *list of lists*. Each inner list
  will form a row in the resulting table. I already insert a header
  row with the names of three columns. An separator line can be obtained
  by having the =hline= symbol in the resulting list.

  #+NAME: make-table1
  #+BEGIN_SRC emacs-lisp :results value :exports both
    (cons '(col1 col2 col3)
          (cons 'hline
                (loop for i from 5 to 15 collect `(,i ,(* i 5) ""))))
  #+END_SRC

  #+TBLNAME: table1
  #+RESULTS: make-table1
  | col1 | col2 | col3 |
  |------+------+------|
  |    5 |   25 |      |
  |    6 |   30 |      |
  |    7 |   35 |      |
  |    8 |   40 |      |
  |    9 |   45 |      |
  |   10 |   50 |      |
  |   11 |   55 |      |
  |   12 |   60 |      |
  |   13 |   65 |      |
  |   14 |   70 |      |
  |   15 |   75 |      |


  We now can fill the third column by passing the table into the next
  source block.  We force babel to treat the first row as table header
  by using the *:colnames yes* header argument. This also causes the
  result table to contain the headers (as long as the new table has the
  same number of columns as the original table)
  
  #+BEGIN_SRC emacs-lisp -n :results value :var tbl=table1 :colnames yes :exports both
    (let (result)
      (dolist (row tbl result)
        (setf (nth 2 row) (* 2 (nth 1 row)))
        (setq result (cons row result)))
      (reverse result))
  #+END_SRC

  #+RESULTS:
  | col1 | col2 | col3 |
  |------+------+------|
  |    5 |   25 |   50 |
  |    6 |   30 |   60 |
  |    7 |   35 |   70 |
  |    8 |   40 |   80 |
  |    9 |   45 |   90 |
  |   10 |   50 |  100 |
  |   11 |   55 |  110 |
  |   12 |   60 |  120 |
  |   13 |   65 |  130 |
  |   14 |   70 |  140 |
  |   15 |   75 |  150 |

  
* calling source blocks as a function
** simple call syntax

   We first define a function
  #+NAME: mydouble
  #+header: :var x=2
  #+BEGIN_SRC emacs-lisp :results silent
  (* 2 x)
  #+END_SRC

  Now we can call this babel function "mydouble" from any place in the document
  #+CALL: mydouble(x=5)

  #+RESULTS:
  : 10


  #+NAME: mydivide
  #+header: :var x=2 y=3
  #+BEGIN_SRC emacs-lisp :results silent
  (/ x y)
  #+END_SRC

  Note that you can pass additional header arguments to the call. The ones
  added at the end influence the final result, while the ones added in
  [] are evaluated in the context of the original definition.
  #+CALL: mydivide(12,3) :results raw

  #+RESULTS:
  4

  #+CALL: mydivide(y=2,x=10)

  #+RESULTS:
  : 5

  Note that I *can have another piece of code implicitely called* by using its name
  as an input variable in a normal code block. So, I could directly fill the third
  column of our initial example table without ever printing out the initial example
  table, by just using as an input (tbl) the name of the initial code block.

  #+BEGIN_SRC emacs-lisp  :results value :var tbl=make-table1 :colnames yes
    (let (result)
      (dolist (row tbl result)
        (setf (nth 2 row) (* 2 (nth 1 row)))
        (setq result (cons row result)))
      (reverse result))  
  #+END_SRC

  #+RESULTS:
  | col1 | col2 | col3 |
  |------+------+------|
  |    5 |   25 |   50 |
  |    6 |   30 |   60 |
  |    7 |   35 |   70 |
  |    8 |   40 |   80 |
  |    9 |   45 |   90 |
  |   10 |   50 |  100 |
  |   11 |   55 |  110 |
  |   12 |   60 |  120 |
  |   13 |   65 |  130 |
  |   14 |   70 |  140 |
  |   15 |   75 |  150 |

  

* Inline src calls
  This is the result of an inline src call in lisp:
  src_emacs-lisp[:var tbl=table1 :results raw]{(nth 0 (nth (- (length tbl) 1) tbl))} 15

  and this is another:
  src_emacs-lisp[:results raw]{(org-table-get-remote-range "table1" "@>$1" )} 15


  src_emacs-lisp[:results value]{(org-table-get-remote-range "table1" "@>$1" )} =15=

* Defining buffer wide variables for src blocks
  One can use a verbatim block like this

  #+NAME: myvar
  : world

  #+BEGIN_SRC emacs-lisp :var s=myvar
  (concat "hello " s)
  #+END_SRC

  #+RESULTS:
  : hello world

* Problems, Questions
  - [ ] How can I produce an initial table by code that already has a
    nicely separated (dashes) column name row? *:colnames yes* only produces
    such a table heading if a table of the same dimension was read in by the
    *:var* directive

* COMMENT org babel settings

Local variables:
org-confirm-babel-evaluate: nil
org-export-babel-evaluate: nil
End:
